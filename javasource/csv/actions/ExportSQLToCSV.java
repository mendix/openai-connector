// This file was generated by Mendix Studio Pro.
//
// WARNING: Only the following code will be retained when actions are regenerated:
// - the import list
// - the code between BEGIN USER CODE and END USER CODE
// - the code between BEGIN EXTRA CODE and END EXTRA CODE
// Other code you write will be lost the next time you deploy the project.
// Special characters, e.g., é, ö, à, etc. are supported in comments.

package csv.actions;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.math.BigDecimal;
import java.sql.Clob;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.Statement;
import java.sql.Time;
import java.sql.Timestamp;
import java.sql.Types;
import java.util.Calendar;
import java.util.Date;
import java.util.TimeZone;
import java.util.function.Function;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;
import com.mendix.core.Core;
import com.mendix.logging.ILogNode;
import com.mendix.systemwideinterfaces.core.IContext;
import com.mendix.systemwideinterfaces.core.IMendixObject;
import com.mendix.webui.CustomJavaAction;
import com.opencsv.CSVWriter;
import csv.impl.CSV;
import system.proxies.FileDocument;

/**
 * This action exports the result of a SQL query to CSV.
 * 
 * Upsides:
 * - It is suitable for high volumes because it uses statement cursors to iterate over the data which increases performance and memory consumption (compared to the pagination approach of OQL).
 * 
 * Downsides:
 * - No prepared statements
 * - Database specific
 *  
 */
public class ExportSQLToCSV extends CustomJavaAction<IMendixObject>
{
	private java.lang.String statement;
	private java.lang.Boolean exportHeaders;
	private java.lang.String returnEntity;
	private java.lang.Boolean zipResult;
	private java.lang.String separator;
	private java.lang.String quoteCharacter;
	private java.lang.String escapeCharacter;
	private java.lang.String characterSet;

	public ExportSQLToCSV(IContext context, java.lang.String statement, java.lang.Boolean exportHeaders, java.lang.String returnEntity, java.lang.Boolean zipResult, java.lang.String separator, java.lang.String quoteCharacter, java.lang.String escapeCharacter, java.lang.String characterSet)
	{
		super(context);
		this.statement = statement;
		this.exportHeaders = exportHeaders;
		this.returnEntity = returnEntity;
		this.zipResult = zipResult;
		this.separator = separator;
		this.quoteCharacter = quoteCharacter;
		this.escapeCharacter = escapeCharacter;
		this.characterSet = characterSet;
	}

	@java.lang.Override
	public IMendixObject executeAction() throws Exception
	{
		// BEGIN USER CODE
		IMendixObject result = Core.dataStorage().executeWithConnection(
				getContext(),
				executeExport(statement, returnEntity,  
						zipResult, separator, quoteCharacter));
		return result;
		// END USER CODE
	}

	/**
	 * Returns a string representation of this action
	 * @return a string representation of this action
	 */
	@java.lang.Override
	public java.lang.String toString()
	{
		return "ExportSQLToCSV";
	}

	// BEGIN EXTRA CODE
	private Function<Connection, IMendixObject> executeExport(
			String sql, String returnEntity, 
			Boolean zipResult, String separator, String quoteCharacter) throws Exception {
	return connection -> {
		ILogNode logger = CSV.getLogger();
		try {
			final int PAGE_SIZE = 100000;
			
			
			String suffix = ".csv";
			if (this.zipResult) {
				suffix += ".zip";
			}
			File tmpFile = File.createTempFile("Export", suffix);
			OutputStream os;
			FileOutputStream fos = new FileOutputStream(tmpFile);
			ZipOutputStream zos = null;
			if (zipResult) {
				zos = new ZipOutputStream(fos);
				zos.putNextEntry(new ZipEntry(tmpFile.getName().replaceAll(".zip", "")));
				os = zos;
			} else {
				os = fos;
			}
			
			CSVWriter writer = new CSVWriter(new OutputStreamWriter(os, (this.characterSet != null ? this.characterSet : "UTF-8")),
					separator == null ? CSVWriter.DEFAULT_SEPARATOR : separator.charAt(0),
					quoteCharacter == null ? CSVWriter.NO_QUOTE_CHARACTER : quoteCharacter.charAt(0),
					escapeCharacter == null ? CSVWriter.NO_ESCAPE_CHARACTER : escapeCharacter.charAt(0),
					System.lineSeparator());
			
			IMendixObject result = Core.instantiate(getContext(), this.returnEntity);
			
			logger.debug("Executing query");
			
			Statement statement = connection.createStatement(ResultSet.TYPE_FORWARD_ONLY, 
					ResultSet.CONCUR_READ_ONLY);
			statement.setFetchSize(PAGE_SIZE);
			
			ResultSet rs = statement.executeQuery(sql);
			ResultSetMetaData metaData = rs.getMetaData();
			
			if (exportHeaders) {
				String[] headers = new String[metaData.getColumnCount()];
				for (int i = 0; i < headers.length; i++) {
					headers[i] = metaData.getColumnName(i + 1);
				}
				writer.writeNext(headers);
			}
			
			while(rs.next()) {
				String[] csvRow = new String[metaData.getColumnCount()];
				for (int i = 1; i < metaData.getColumnCount() + 1; i++) {
					String val = null;
					switch (metaData.getColumnType(i)) {
					case Types.BOOLEAN:
						val = Boolean.toString(rs.getBoolean(i));
						break;
					case Types.BIGINT:
						BigDecimal bd = rs.getBigDecimal(i);
						if (bd != null)
							val = bd.toPlainString();
						break;
					case Types.CLOB:
						Clob clob = rs.getClob(i);
						if (clob != null) {
							val = clob.getSubString(0, (int) clob.length());
						}
						break;
					case Types.TIME:
					case Types.TIME_WITH_TIMEZONE:
						Time t = rs.getTime(i);
						if (t != null) {
							val = Long.toString(t.getTime());
						}
						break;
					case Types.TIMESTAMP:
					case Types.TIMESTAMP_WITH_TIMEZONE:
						Timestamp ts = rs.getTimestamp(i, 
								Calendar.getInstance(TimeZone.getTimeZone("UTC")));
						if (ts != null) {
							val = Long.toString(ts.getTime());
						}
						break;
					case Types.DATE:
						Date date = rs.getDate(i);
						if (date != null) {
							val = Long.toString(date.getTime());
						}
						break;
					case Types.NUMERIC:
					case Types.DECIMAL:
						BigDecimal r = rs.getBigDecimal(i);
						if (r != null) {
							val = r.toString();
						}
						break;
					case Types.DOUBLE:
						Double d = rs.getDouble(i);
						if (d != null) {
							val = d.toString();
						}
						break;
					case Types.FLOAT:
						float f = rs.getFloat(i);
						val = Float.toString(f);
						break;
					case Types.SMALLINT:
					case Types.INTEGER:
						int in = rs.getInt(i);
						val = Integer.toString(in);
						break;
					case Types.NCHAR:
					case Types.NVARCHAR:
					case Types.VARCHAR:
					case Types.CHAR:
						val = rs.getString(i);
						break;
					
					}
					csvRow[i - 1] = val;
				}
				writer.writeNext(csvRow);
			}
			
			try {
				rs.close();
				statement.close();
			} catch (Exception e) {}
			
			writer.close();
			result.setValue(getContext(), FileDocument.MemberNames.Name.toString(), tmpFile.getName());
			Core.storeFileDocumentContent(getContext(), result, new FileInputStream(tmpFile));
			tmpFile.delete();
			
			return result;
		} catch (Exception e) {
			logger.error("Error while exporting using SQL : " + e.toString(), e);
			throw new RuntimeException(e);
		}
	};
}
	// END EXTRA CODE
}
